---
import Layout from "@layouts/Layout.astro";
import { Icon } from "astro-icon/components";
import { Image } from "astro:assets";

import andromedaLogoDark from "@assets/images/icons/andromedaLogoDark.png";
import andromedaLogoLight from "@assets/images/icons/andromedaLogoLight.png";

const link = Astro.url.searchParams.get("redir");
---

<Layout>
    <div class="h-full flex items-center justify-center font-inter">
        <div class="flex flex-col items-center gap-6">
            <div class="flex items-center gap-2">
                <Image src={andromedaLogoDark} alt="Andromeda" class="h-16 w-16 logo-dark" />
                <Image src={andromedaLogoLight} alt="Andromeda" class="h-16 w-16 logo-light" />
                <h1 class="text-6xl font-semibold">Andromeda</h1>
            </div>
            <div id="searchForm" class="flex items-center bg-(--search-bg) rounded-full border border-(--search-border) w-4/5 md:w-[26rem] h-12 shadow-lg transition-shadow duration-200 hover:shadow-xl focus-within:shadow-xl focus-within:border-(--search-focus-border)">
                <Icon name="lucide:search" class="ml-5 h-5 w-5 text-(--muted-foreground)" />
                <input id="input" type="text" name="Search" class="flex-1 outline-none rounded-full bg-transparent text-(--foreground) placeholder:text-(--muted-foreground) px-4 py-3 text-base" placeholder="Search the web">
            </div>
            {/** <div class="w-full flex flex-row gap-2">
                <div class="rounded-md border-2">
                    t
                </div>
            </div> */}
        </div>
        <iframe id="iframe" class="fixed h-[calc(100%-3.5rem)] mt-14 w-full hidden bg-(--background)" />
        <link-element data-link={link} />
    </div>
</Layout>
<style>
    /* Logo switching based on theme */
    /* logo-dark class = dark colored logo (for light theme backgrounds) */
    /* logo-light class = light colored logo (for dark theme backgrounds) */
    .logo-dark {
        display: none;
    }
    .logo-light {
        display: block;
    }
    :global(.light) .logo-dark {
        display: block;
    }
    :global(.light) .logo-light {
        display: none;
    }
    :global(.dark) .logo-dark {
        display: none;
    }
    :global(.dark) .logo-light {
        display: block;
    }
</style>
<script>
    import { SW, decodeScramjetURL } from "@utils/proxy.ts";
    import { Settings } from "@utils/settings.ts";
    import { BareClient } from "@mercuryworkshop/bare-mux";
    import { setupIframeInterceptor } from "@utils/iframe-interceptor.ts";

    const init = async () => {
        const input = document.getElementById("input") as HTMLInputElement;
        const iframe = document.getElementById("iframe") as HTMLIFrameElement;
        const iframeWin = iframe.contentWindow;
        const bhl = document.getElementById("bhl") as HTMLDivElement;
        const phl = document.getElementById("phl") as HTMLDivElement;
        const phlImage = document.getElementById("phlImage") as HTMLImageElement;
        const phlTitle = document.getElementById("phlTitle") as HTMLDivElement;
        const proxyLeft = document.getElementById("pal") as HTMLButtonElement;
        const proxyRight = document.getElementById("par") as HTMLButtonElement;
        const proxyReload = document.getElementById("prl") as HTMLButtonElement;
        const proxyShortcut = {
            button: document.getElementById("psc") as HTMLButtonElement,
            noShortcut: document.getElementById("noShortcut") as HTMLElement,
            shortcut: document.getElementById("shortcut") as HTMLElement
        }
        const client = new BareClient();
        
        // Get SW instance asynchronously and wait for it to be ready
        const sw = await SW.getInstanceAsync();
        await sw.ready();
        
        // Setup iframe interceptor to prevent new tabs/windows
        setupIframeInterceptor(iframe, (url: string) => sw.encodeURL(url));
        
        input.addEventListener("keypress", async (event: any) => {
            if (event.key === "Enter") {
                // Handle "about:" URLs
                const inputValue = input.value.trim();
                const aboutMatch = inputValue.match(/^about:(.+)$/);
                if (aboutMatch) {
                    const target = aboutMatch[1];
                    switch (target) {
                        case 'settings':
                            window.location.href = '/settings';
                            return;
                        case 'home':
                            window.location.href = '/';
                            return;
                        case '404':
                            window.location.href = '/404';
                            return;
                    }
                }

                const settings = await Settings.getInstance();
                iframe.classList.remove("hidden");
                iframe.src = sw.encodeURL(input.value); 
                buttons();
            }
        });

        const getURL = async (): Promise<string> => {
            if (iframeWin!.__uv) {
                return iframeWin!.__uv.location.href
            }
            else if (iframeWin!.$scramjet) {
                // Scramjet stores the original URL in the client's url property
                if (iframeWin!.$scramjet.url) {
                    return iframeWin!.$scramjet.url.href || iframeWin!.$scramjet.url.toString();
                } else if (iframeWin!.$scramjet.config?.prefix) {
                    // Fallback: decode from the location href
                    const scramjetURL = iframeWin!.location.href;
                    const prefix = iframeWin!.$scramjet.config.prefix;
                    let encoded = scramjetURL
                        .replace(iframeWin!.location.origin, '')
                        .replace(prefix, '');
                    // Handle hash fragments
                    const hashIndex = encoded.indexOf('#');
                    let hash = '';
                    if (hashIndex !== -1) {
                        hash = encoded.slice(hashIndex);
                        encoded = encoded.slice(0, hashIndex);
                    }
                    return decodeScramjetURL(encoded) + hash;
                }
                return iframeWin!.location.href;
            }
            else {
                // Fallback if neither proxy is available
                return iframeWin!.location.href;
            }
        }

        // Helper function to extract domain from URL for favicon fetching
        const extractDomain = (url: string): string => {
            try {
                return new URL(url).hostname;
            } catch {
                return url;
            }
        };

        // Helper function to fetch favicon with fallback sources
        const fetchFavicon = async (pageURL: string): Promise<string> => {
            const domain = extractDomain(pageURL);
            
            // Try to get favicon from the iframe's document first (most reliable)
            try {
                const iframeDoc = iframeWin?.document;
                if (iframeDoc) {
                    // Look for link elements with rel containing "icon"
                    const iconLinks = iframeDoc.querySelectorAll('link[rel*="icon"]');
                    for (const link of iconLinks) {
                        const href = (link as HTMLLinkElement).href;
                        if (href) {
                            // Verify the favicon is accessible
                            try {
                                const response = await client.fetch(href);
                                if (response.ok) {
                                    const blob = await response.blob();
                                    return URL.createObjectURL(blob);
                                }
                            } catch {
                                // Continue to next link or fallback
                            }
                        }
                    }
                }
            } catch {
                // Cross-origin or other error, use fallbacks
            }

            // Fallback sources for favicons
            const faviconSources = [
                // Google's favicon service (most reliable)
                `https://www.google.com/s2/favicons?domain=${domain}&sz=64`,
                // DuckDuckGo favicon service
                `https://icons.duckduckgo.com/ip3/${domain}.ico`,
                // Direct favicon.ico from the site
                `https://${domain}/favicon.ico`,
                // Alternative: apple-touch-icon
                `https://${domain}/apple-touch-icon.png`,
            ];

            for (const source of faviconSources) {
                try {
                    const response = await client.fetch(source);
                    if (response.ok) {
                        const blob = await response.blob();
                        // Verify we got a valid image
                        if (blob.size > 0 && blob.type.startsWith('image/')) {
                            return URL.createObjectURL(blob);
                        }
                    }
                } catch {
                    // Try next source
                }
            }

            // Return empty string if all sources fail
            return '';
        };

        const buttons = () => {
            proxyLeft.addEventListener("click", () => {
                iframeWin!.history.back();
            });
            proxyRight.addEventListener("click", () => {
                iframeWin!.history.forward();
            });
            proxyReload.addEventListener("click", () => {
                iframeWin!.location.reload();
            });
            /** proxyShortcut.button.addEventListener("click", () => {
                console.log("yet to be implemented");
            }); */
        }

        iframe.addEventListener("load", async () => {
            try {
                phlTitle.innerHTML = iframeWin!.document.title || 'Untitled';
            } catch {
                phlTitle.innerHTML = 'Untitled';
            }
            
            const pageURL = await getURL();
            const faviconUrl = await fetchFavicon(pageURL);
            
            if (faviconUrl) {
                phlImage.src = faviconUrl;
            } else {
                // Use a default favicon if none found
                phlImage.src = '/favicon.png';
            }
            
            bhl.classList.add("hidden");
            phl.classList.remove("hidden");
        }); 
    }

    class CustomComponent extends HTMLElement {
        connectedCallback() {
            const link = this.dataset.link;
            const input = document.getElementById("input") as HTMLInputElement;
            if (link) {
                return (async () => {
                    await init();
                    try {
                        // Decode base64 to UTF-8 string using standard pattern
                        input.value = decodeURIComponent(escape(atob(link)));
                    } catch (_) {
                        // Fallback: try decodeURIComponent for URL-encoded values
                        try {
                            input.value = decodeURIComponent(link);
                        } catch {
                            input.value = link;
                        }
                    }
                    input.dispatchEvent(new KeyboardEvent("keypress", { key: "Enter", code: "Enter" }));
                    history.pushState({}, "", "/");
                })();
            }
        }
    }
    
    customElements.define('link-element', CustomComponent);
    document.addEventListener("astro:page-load", async () => {
        try {
            await init();
        }
        catch (_) {}
    });
</script>
